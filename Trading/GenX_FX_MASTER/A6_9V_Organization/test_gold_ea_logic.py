#!/usr/bin/env python3
"""
Test Script for Gold Master EA Logic
Simulates the EA's decision-making process
"""

import csv
import os
from datetime import datetime

class GoldEASimulator:
    def __init__(self):
        self.base_risk = 1.0
        self.max_risk_per_trade = 5.0
        self.min_confidence = 75.0
        self.high_confidence = 85.0
        self.very_high_confidence = 90.0
        self.max_confidence_multiplier = 4.0
        
        self.gold_pairs = ["XAUUSD", "XAUEUR", "XAUGBP", "XAUAUD", "XAUCAD", "XAUCHF"]
        self.enabled_pairs = {
            "XAUUSD": True,
            "XAUEUR": True, 
            "XAUGBP": True,
            "XAUAUD": True,
            "XAUCAD": False,
            "XAUCHF": False
        }
        
    def is_gold_pair(self, symbol):
        return symbol.startswith("XAU")
    
    def is_pair_enabled(self, symbol):
        return self.enabled_pairs.get(symbol, False)
    
    def calculate_confidence_risk(self, confidence):
        """Calculate risk multiplier based on confidence"""
        confidence = float(confidence) * 100  # Convert decimal to percentage
        
        if confidence >= self.very_high_confidence:
            multiplier = self.max_confidence_multiplier  # 90%+ = 4x
        elif confidence >= self.high_confidence:
            multiplier = 2.5  # 85%+ = 2.5x
        elif confidence >= 80.0:
            multiplier = 1.5  # 80%+ = 1.5x
        else:
            multiplier = 1.0  # Default
            
        calculated_risk = self.base_risk * multiplier
        
        # Apply safety cap
        if calculated_risk > self.max_risk_per_trade:
            calculated_risk = self.max_risk_per_trade
            
        return calculated_risk, multiplier
    
    def process_signals(self, csv_file):
        """Process signals like the EA would"""
        results = []
        
        print("ü•á Gold Master EA Simulation Test")
        print("=" * 50)
        
        if not os.path.exists(csv_file):
            print(f"‚ùå Signal file not found: {csv_file}")
            return results
            
        with open(csv_file, 'r') as file:
            reader = csv.reader(file)
            header = next(reader)  # Skip header
            
            gold_signals = 0
            processed_signals = 0
            
            for row in reader:
                if len(row) < 8:
                    continue
                    
                magic, symbol, signal, entry_price, stop_loss, take_profit, lot_size, timestamp = row
                confidence = float(lot_size)  # Using lot_size field as confidence for demo
                
                # Check if it's a gold pair
                if not self.is_gold_pair(symbol):
                    continue
                    
                gold_signals += 1
                
                # Check if pair is enabled
                if not self.is_pair_enabled(symbol):
                    print(f"‚è≠Ô∏è  {symbol} {signal} - SKIPPED (pair disabled)")
                    continue
                
                # Check confidence threshold
                confidence_pct = confidence * 100
                if confidence_pct < self.min_confidence:
                    print(f"‚è≠Ô∏è  {symbol} {signal} - SKIPPED (confidence {confidence_pct:.1f}% < {self.min_confidence}%)")
                    continue
                
                # Calculate risk
                risk_percent, multiplier = self.calculate_confidence_risk(confidence)
                
                print(f"ü•á {symbol} {signal}")
                print(f"   üí° Confidence: {confidence_pct:.1f}% ‚Üí Risk: {risk_percent:.1f}% (√ó{multiplier})")
                print(f"   üí∞ Entry: {entry_price} | SL: {stop_loss} | TP: {take_profit}")
                print(f"   ‚úÖ WOULD EXECUTE TRADE")
                print()
                
                results.append({
                    'symbol': symbol,
                    'signal': signal,
                    'confidence': confidence_pct,
                    'risk_percent': risk_percent,
                    'multiplier': multiplier,
                    'entry_price': float(entry_price)
                })
                
                processed_signals += 1
        
        print(f"üìä Test Summary:")
        print(f"   Total gold signals found: {gold_signals}")
        print(f"   Signals processed: {processed_signals}")
        print(f"   Signals executed: {len(results)}")
        print()
        
        return results
    
    def test_risk_scaling(self):
        """Test confidence-based risk scaling"""
        print("üéØ Risk Scaling Test")
        print("=" * 30)
        
        test_confidences = [0.72, 0.78, 0.82, 0.87, 0.92, 0.95]
        
        for conf in test_confidences:
            risk, mult = self.calculate_confidence_risk(conf)
            conf_pct = conf * 100
            print(f"Confidence {conf_pct:5.1f}% ‚Üí Risk {risk:5.1f}% (√ó{mult:.1f})")
        print()

def main():
    simulator = GoldEASimulator()
    
    # Test 1: Risk scaling logic
    simulator.test_risk_scaling()
    
    # Test 2: Process actual signals
    csv_file = "signal_output/MT4_Signals.csv"
    results = simulator.process_signals(csv_file)
    
    # Test 3: Analyze results
    if results:
        print("üìà Analysis:")
        avg_confidence = sum(r['confidence'] for r in results) / len(results)
        avg_risk = sum(r['risk_percent'] for r in results) / len(results)
        
        print(f"   Average confidence: {avg_confidence:.1f}%")
        print(f"   Average risk: {avg_risk:.1f}%")
        
        high_conf_trades = [r for r in results if r['confidence'] >= 90]
        print(f"   High confidence trades (90%+): {len(high_conf_trades)}")
        
        if high_conf_trades:
            avg_high_risk = sum(r['risk_percent'] for r in high_conf_trades) / len(high_conf_trades)
            print(f"   Average risk for high confidence: {avg_high_risk:.1f}%")

if __name__ == "__main__":
    main()